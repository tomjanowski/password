#!/usr/bin/python3
import sys,math
def to_hex(byte):
  x=""
  for i in byte:
    zz=hex(i)
    if i<16: zz="0"+zz[-1]
    x=x+zz[-2:]
  return x
passlen=16
if len(sys.argv)>1:
  passlen=int(sys.argv[1])
if passlen>90:
  raise Exception("Password of this length should be generated by /dev/urandom")
spec=False
digit=False
if len(sys.argv)>2:
  if sys.argv[2]=='s':
    spec=True
  elif sys.argv[2]=='d':
    digit=True
max_iter=1
if len(sys.argv)>3:
  max_iter=int(sys.argv[3])
#
if max_iter>1:
  f=open("/dev/urandom","rb",buffering=0)
  print("Opening /dev/urandom",file=sys.stderr)
else:
  f=open("/dev/random","rb",buffering=0)
  print("Opening /dev/random",file=sys.stderr)
x=str()
select=r'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz{}!#$%&()*+,-./:;<=>?@[]^_|'
# Nest Bank requirements:
#select=r'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$&*<>@^'
if not spec:
  select=r'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
if digit:
  select=r'0123456789'
length=len(select)
ssize=math.ceil(math.log2(length)*passlen/8)-1
biggest_value=length**passlen
ratio=0
while ratio<128:
  ssize=ssize+1
  removebits=ssize*8-math.ceil(math.log2(length)*passlen)
  biggest_random=256**ssize
  ratio=biggest_random//biggest_value
  if ratio<1: raise Exception("Bad ratio")
biggest_accepted=ratio*biggest_value
print("Random bytes read: ",  ssize,file=sys.stderr)
print("trailing bits to zero",removebits,file=sys.stderr)
print("Password length:   ",  passlen,file=sys.stderr)
print("Ratio:             ",  ratio,file=sys.stderr)
dist={}
for i in select:
  dist[i]=0
el=-1
repeats=0
for i in range(0,max_iter):
  bytearr=f.read(ssize)
# force the random number distribution to be cut-off on the boundary
# of the power of length. Without this we have an out-of-boundary
# cutoff that results in unbalanced probabilities on the tail side of
# the last digit. With this, the distribution is perfect (tested).
# tested again in 2022-22-21 and the ratio of the largest and the 
# smallest number of 'hits' is approx. 1+34/sqrt(max_iter)
# Added efficiency improvement by more efficiently utilizing existing bits
# Note that we just simply convert the big integer number into a
# representation with a base that is the size of the array of characters
# and thus is why we reject numbers that a larger than this "encoding",
# i.e. base to the power of number of chars in the password.
# The impovement: Add extra byte and utilize all numbers to the largest
# multiple of the biggest_value, discard the tail
  while True:
    bigint=int.from_bytes(bytearr,byteorder='big')
    if max_iter==1:
      print("Integer: {0:50X}".format(bigint),end="\n",file=sys.stderr)
      print("MAX:     {0:50X}".format(biggest_accepted),end="\n",file=sys.stderr)
    if bigint<biggest_accepted: 
      break
#   print(": rejected")
    repeats=repeats+1
    onebyte=f.read(1)
    bytearr=bytearr[1:]+onebyte
    if max_iter==1:
      print("Adding one byte...",file=sys.stderr)
  x=""
  while len(x)<passlen:
    x+=select[bigint%length]
    bigint=bigint//length
  if not x[el] in dist:  dist[x[el]]=0
  dist[x[el]]=dist[x[el]]+1
#for i in sorted(dist.items(),key=lambda x: x[1]):
#  print(i)
if max_iter>1:
  xx=sorted(dist.items(),key=lambda x: x[1])
  div=100
  try:
    div=xx[-1][1]/xx[0][1]
  except:
    div=float("NaN")
  print("{0:12} {1:18.15f} # max,min: {2} {3}, repeats: {4:10d}".format(max_iter,div,xx[-1][0],xx[0][0],repeats))
else:
  print(x)
